/*
 * Copyright (C) 2023 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.copybara.util;

import static com.google.common.collect.ImmutableSet.toImmutableSet;
import static com.google.copybara.exception.ValidationException.checkCondition;
import static java.nio.charset.StandardCharsets.UTF_8;
import static net.starlark.java.eval.StarlarkSemantics.DEFAULT;

import com.google.common.base.Splitter;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.hash.HashCode;
import com.google.common.hash.HashFunction;
import com.google.common.io.MoreFiles;
import com.google.copybara.CoreGlobal;
import com.google.copybara.exception.RepoException;
import com.google.copybara.exception.ValidationException;
import com.google.re2j.Pattern;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.InvalidPathException;
import java.nio.file.Path;
import java.nio.file.PathMatcher;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;
import java.util.stream.Stream;
import net.starlark.java.eval.EvalException;
import net.starlark.java.eval.Module;
import net.starlark.java.eval.Mutability;
import net.starlark.java.eval.Starlark;
import net.starlark.java.eval.StarlarkThread;
import net.starlark.java.syntax.FileOptions;
import net.starlark.java.syntax.ParserInput;
import net.starlark.java.syntax.SyntaxError;

/**
 * SinglePatch represents the difference between what exists in the destination files and the output
 * of an import created by Copybara. This will only be different when using merge import mode,
 * because otherwise the destination files will be overwritten and there will be no difference.
 */
public class SinglePatch {

  private static final String HEADER =
      "" + "# This file is generated by Copybara.\n" + "# Do not edit.\n";

  private static final String HASH_DELIMITER = "--hash-delimiter--";
  private static final String DESTINATION_FILES_DELIMITER =
      "--destination-files-delimiter--";

  private final ImmutableMap<String, String> fileHashes;
  private final byte[] diffContent;

  private final Glob destinationFiles;

  public SinglePatch(ImmutableMap<String, String> fileHashes, byte[] diffContent,
      Glob destinationFiles) {
    this.fileHashes = fileHashes;
    this.diffContent = diffContent;
    this.destinationFiles = destinationFiles;
  }

  /**
   * Create a SinglePatch object from two folders containing separate versions of the repository.
   *
   * <p>The location of the two folders matters. The SinglePatch includes a diff between the two
   * folders which the parent of the destination will be used as the working directory for when
   * created. The locations of the folders will affect the paths that appear in the diff output.
   *
   * @param baseline is the version to diff against.
   * @param destination is the version containing all the destination only changes.
   * @param destinationFiles describes what files should be included in the patch.
   */
  public static SinglePatch generateSinglePatch(Path baseline, Path destination,
      HashFunction hashFunction, Map<String, String> environment, Glob destinationFiles)
      throws IOException, InsideGitDirException {
    ImmutableMap.Builder<String, String> hashesBuilder = ImmutableMap.builder();
    Files.walkFileTree(destination, new SimpleFileVisitor<>() {
      @Override
      public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
          throws IOException {
        HashCode hashCode = MoreFiles.asByteSource(file).hash(hashFunction);
        hashesBuilder.put(destination.relativize(file).toString(),
            hashCode.toString());
        return FileVisitResult.CONTINUE;
      }

    });
    byte[] diff = DiffUtil.diff(baseline, destination, true, environment);
    return new SinglePatch(hashesBuilder.build(), diff, destinationFiles);
  }

  private static String mustReadLine(BufferedReader reader) throws IOException {
    String line = reader.readLine();
    if (line == null) {
      throw new IOException("failed to parse single patch file: unexpected end of file");
    }
    return line;
  }

  private static String mustReadUncommentedLine(BufferedReader reader) throws IOException {
    String line = mustReadLine(reader);
    while (line.startsWith("#")) {
      line = mustReadLine(reader);
    }
    return line;
  }

  private static Glob evaluateDestinationFilesGlob(String destinationFilesSection)
      throws ValidationException {

    // sanity check the input
    final String globRegex = "^glob\\(.*\\)$";
    Pattern pattern = Pattern.compile(globRegex);
    checkCondition(pattern.matches(destinationFilesSection),
        "destination files has incorrect format");

    try (Mutability mu = Mutability.create("CopybaraSinglePatch")) {
      StarlarkThread thread = new StarlarkThread(mu, DEFAULT);
      ParserInput input = ParserInput.fromString(destinationFilesSection, "single-patch");
      ImmutableMap.Builder<String, Object> envBuilder = ImmutableMap.builder();
      Starlark.addMethods(envBuilder, new CoreGlobal());
      return (Glob) Starlark.eval(input, FileOptions.DEFAULT,
          Module.withPredeclared(DEFAULT, envBuilder.build()), thread);
    } catch (SyntaxError.Exception | EvalException | InterruptedException e) {
      throw new ValidationException("Failed to parseSinglePatch destination files", e);
    }
  }

  public static SinglePatch fromBytes(byte[] bytes)
      throws IOException, ValidationException {
    try (
        ByteArrayInputStream in = new ByteArrayInputStream(bytes);
        BufferedReader br = new BufferedReader(new InputStreamReader(in))
    ) {
      ImmutableMap.Builder<String, String> fileHashesBuilder = new ImmutableMap.Builder<>();
      String line = mustReadUncommentedLine(br);

      StringBuilder destinationFilesSectionBuilder = new StringBuilder();
      while (!line.equals(DESTINATION_FILES_DELIMITER)) {
        destinationFilesSectionBuilder.append(line);
        line = mustReadUncommentedLine(br);
      }
      Glob destination = evaluateDestinationFilesGlob(destinationFilesSectionBuilder.toString());

      line = mustReadUncommentedLine(br);
      while (!line.equals(HASH_DELIMITER)) {
        List<String> splits = Splitter.on(": ").limit(2).splitToList(line);
        if (splits.size() != 2) {
          throw new IOException(
              "failed to parse single patch hashes: unexpected number of elements");
        }
        validateParsedPathValue(splits.get(0));
        validateParsedHashValue(splits.get(1));
        fileHashesBuilder.put(splits.get(0), splits.get(1));

        line = mustReadUncommentedLine(br);
      }

      line = br.readLine(); // can be null if there is no diff output
      ByteArrayOutputStream diffContentOut = new ByteArrayOutputStream();
      try (OutputStreamWriter diffContentWriter = new OutputStreamWriter(diffContentOut)) {
        while (line != null) {
          diffContentWriter.write(line + "\n");
          line = br.readLine();
        }
      }

      return new SinglePatch(
          fileHashesBuilder.buildOrThrow(), diffContentOut.toByteArray(), destination);
    }
  }

  ImmutableMap<String, String> getFileHashes() {
    return ImmutableMap.copyOf(fileHashes);
  }

  byte[] getDiffContent() {
    return Arrays.copyOf(diffContent, diffContent.length);
  }

  Glob getDestinationFiles() {
    return destinationFiles;
  }

  public byte[] toBytes() throws IOException {
    ByteArrayOutputStream out = new ByteArrayOutputStream();

    // OutputStreamWriter for this part for idiomatic string writing
    try (OutputStreamWriter outWriter = new OutputStreamWriter(out)) {
      outWriter.write(HEADER);

      outWriter.write(destinationFiles + "\n");
      outWriter.write(DESTINATION_FILES_DELIMITER + "\n");

      for (Entry<String, String> entry : fileHashes.entrySet()) {
        outWriter.write(String.format("%s: %s\n",
            entry.getKey(),
            entry.getValue()));
      }
      outWriter.write(HASH_DELIMITER + "\n");
    }

    out.write(diffContent);

    return out.toByteArray();
  }

  /**
   * reverseSinglePatch applies the diff contained in the patch in reverse on the input destination
   * directory, obtaining the origin directory sans any destination-only changes.
   */
  public void reverseSinglePatch(Path dir, Map<String, String> environment)
      throws IOException, ValidationException {
    AutoPatchUtil.reversePatch(dir, this.getDiffContent(), environment);
  }

  /**
   * Functional interface for obtaining a hash, given a file.
   */
  public interface HashGetter {

    String getHashString(String filePath) throws IOException, RepoException;
  }

  /**
   * Return a {@link HashGetter} that obtains the hash by reading the file at the path relative to
   * the passed in directory and hashing it.
   */
  public static HashGetter simpleHashGetter(Path dir, HashFunction hashFunction) {
    return (String path) -> MoreFiles.asByteSource(dir.resolve(path)).hash(hashFunction).toString();
  }

  /**
   * A utility method for obtaining a list of files from a directory.
   */
  public static ImmutableSet<String> filesInDir(Path dir) throws IOException {
    try (Stream<Path> files = Files.walk(dir)) {
      return files
          .filter(file -> !Files.isDirectory(file))
          .map(dir::relativize)
          .map(Path::toString)
          .collect(toImmutableSet());
    }
  }

  /**
   * Validating will apply some checks verify that a directory matches the state of the
   * destination directory used when this SinglePatch was created.
   *
   * <p>This check can detect if changes were made to the destination that the SinglePatch
   * does not account for. If such changes exist, then it does not make sense to use this
   * SinglePatch to construct the baseline, and {@link #reverseSinglePatch(Path, Map)} should not be
   * used on the passed-in directory.
   *
   * @param files is a list of relative paths of all files in the directory
   * @param hashFetcher is a function that obtains the hash of a file, given the relative path
   */
  public void validateDirectory(ImmutableSet<String> files, HashGetter hashFetcher)
      throws IOException, ValidationException, RepoException {
    Path root = Path.of("/");
    PathMatcher destinationFilesMatcher = destinationFiles.relativeTo(root);

    ImmutableSet<String> directoryFiles = files.stream()
        .map(Path::of)
        .map(root::resolve)
        .filter(destinationFilesMatcher::matches)
        .map(root::relativize)
        .map(Path::toString)
        .collect(toImmutableSet());

    // check that all directory files are present in file hashes
    ImmutableSet<String> singlePatchFiles = fileHashes.keySet();
    ImmutableSet<String> directoryOnlyFiles = directoryFiles.stream()
        .filter(file -> !singlePatchFiles.contains(file))
        .collect(toImmutableSet());

    if (!directoryOnlyFiles.isEmpty()) {
      throw new ValidationException(
          String.format("Encountered files in directory not present in SinglePatch: %s",
              directoryOnlyFiles));
    }

    // check that all SinglePatch files are present in directory
    ImmutableSet<String> singlePatchOnlyFiles = singlePatchFiles.stream()
        .filter(file -> !directoryFiles.contains(file))
        .collect(toImmutableSet());

    if (!singlePatchOnlyFiles.isEmpty()) {
      throw new ValidationException(
          String.format("Encountered files not found in directory but present in SinglePatch: %s",
              singlePatchFiles));
    }

    // verify that all file hashes in the directory match the SinglePatch file hashes
    for (Entry<String, String> hashEntry : fileHashes.entrySet()) {
      String fileName = hashEntry.getKey();
      String expectedHash = hashEntry.getValue();
      String actualHash = hashFetcher.getHashString(fileName);
      if (!expectedHash.equals(actualHash)) {
        throw new ValidationException(
            String.format("File %s has hash value %s in SinglePatch but %s in directory",
                fileName, expectedHash, actualHash)
        );
      }
    }
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }

    if (!(obj instanceof SinglePatch)) {
      return false;
    }

    SinglePatch that = (SinglePatch) obj;
    if (!this.fileHashes.equals(that.fileHashes)) {
      return false;
    }

    if (!this.destinationFiles.equals(that.destinationFiles)) {
      return false;
    }

    return Arrays.equals(this.diffContent, that.diffContent);
  }

  @Override
  public int hashCode() {
    return Objects.hash(fileHashes.hashCode(), Arrays.hashCode(this.diffContent));
  }

  @Override
  public String toString() {
    return String.format("%s\n%s\n", fileHashes, new String(diffContent, UTF_8));
  }

  private static void validateParsedPathValue(String path) throws ValidationException {
    try {
      var unused = Path.of(path);
    } catch (InvalidPathException e) {
      throw new ValidationException("Parsed path value is invalid.", e);
    }
  }

  private static void validateParsedHashValue(String hash)
      throws ValidationException {
    try {
      var unused = HashCode.fromString(hash);
    } catch (IllegalArgumentException e) {
      throw new ValidationException("Parsed hash value is invalid.", e);
    }
  }
}
